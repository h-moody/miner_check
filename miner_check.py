import requests
from requests.auth import HTTPDigestAuth
from urllib.parse import urlparse
import subprocess
import logging
from datetime import timedelta
import argparse
import json
import os

# Command-line arguments setup
parser = argparse.ArgumentParser(description="Antminer Monitoring Script")
parser.add_argument('--config', type=str, help='Path to configuration file')
parser.add_argument('--username', type=str, help='Username for miner authentication')
parser.add_argument('--password', type=str, help='Password for miner authentication')
parser.add_argument('--telegram_token', type=str, help='Telegram bot token')
parser.add_argument('--chat_id', type=str, help='Telegram chat ID')
parser.add_argument('--e9_ips', type=str, nargs='*', help='List of E9 Pro miner IP addresses')
parser.add_argument('--l7_ips', type=str, nargs='*', help='List of L7 miner IP addresses')
parser.add_argument('--wallet_e9', type=str, help='Wallet address for E9 Pro miners')
parser.add_argument('--wallet_l7', type=str, help='Wallet address for L7 miners (if fixed)')
parser.add_argument('--wallet_prefix_l7', type=str, help='Wallet address prefix for L7 miners (if generated by prefix)')
parser.add_argument('--max_temp_e9', type=int, help='Maximum CHIP temperature for E9 Pro miners')
parser.add_argument('--max_temp_l7', type=int, help='Maximum CHIP temperature for L7 miners')
parser.add_argument('--min_hashrate_5s_e9', type=int, default=100, help='Minimum 5-second hashrate for E9 Pro miners')
parser.add_argument('--min_hashrate_30m_e9', type=int, default=3300, help='Minimum 30-minute hashrate for E9 Pro miners')
parser.add_argument('--min_hashrate_5s_l7', type=int, default=100, help='Minimum 5-second hashrate for L7 miners')
parser.add_argument('--min_hashrate_30m_l7', type=int, default=8000, help='Minimum 30-minute hashrate for L7 miners')
args = parser.parse_args()

# Load configuration from file if provided
if args.config:
    if os.path.exists(args.config):
        with open(args.config, 'r') as config_file:
            config_data = json.load(config_file)
            # Update args with values from config file if not provided via command line
            for key, value in config_data.items():
                if not getattr(args, key):
                    setattr(args, key, value)
    else:
        raise FileNotFoundError(f"Configuration file {args.config} not found.")

# Set default temperature values if not provided
max_temp_e9 = args.max_temp_e9 if args.max_temp_e9 is not None else 80
max_temp_l7 = args.max_temp_l7 if args.max_temp_l7 is not None else 70

# Logging setup
log_filename = "miner_logs.log"
logging.basicConfig(
    filename=log_filename,
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s", "%Y-%m-%d %H:%M:%S")
console.setFormatter(formatter)
logging.getLogger().addHandler(console)

# Telegram settings
TELEGRAM_API_URL = f"https://api.telegram.org/{args.telegram_token}/sendMessage"
CHAT_ID = args.chat_id

# Function to send messages via Telegram
def send_telegram_message(message):
    data = {'chat_id': CHAT_ID, 'text': message}
    try:
        requests.post(TELEGRAM_API_URL, data=data)
        logging.info(f"Sent Telegram message: {message}")
    except Exception as e:
        logging.error(f"Error sending message to Telegram: {e}")

# Common parameters for miners
username = args.username
password = args.password
auth = HTTPDigestAuth(username, password)

# URL lists for Antminer
miners = {}
if args.e9_ips:
    miners["E9 Pro"] = {
        "urls": [f"http://{ip}" for ip in args.e9_ips],
        "max_temp": max_temp_e9,
        "min_hashrate_5s": args.min_hashrate_5s_e9,
        "min_hashrate_30m": args.min_hashrate_30m_e9,
        "wallet": args.wallet_e9
    }
if args.l7_ips:
    miners["L7"] = {
        "urls": [f"http://{ip}" for ip in args.l7_ips],
        "max_temp": max_temp_l7,
        "min_hashrate_5s": args.min_hashrate_5s_l7,
        "min_hashrate_30m": args.min_hashrate_30m_l7,
        "wallet": args.wallet_l7,
        "wallet_prefix": args.wallet_prefix_l7
    }

# Function to convert time from seconds to readable format
def format_uptime(seconds):
    uptime = timedelta(seconds=seconds)
    days = uptime.days
    hours, remainder = divmod(uptime.seconds, 3600)
    minutes = remainder // 60
    return f"{days}d {hours}h {minutes}m"

# Function to check miner availability via ping
def is_miner_accessible(ip):
    try:
        result = subprocess.run(["ping", "-c", "3", ip], stdout=subprocess.DEVNULL)
        if result.returncode != 0:
            logging.warning(f"Miner {ip} is not accessible via ping.")
            return False
        return True
    except Exception as e:
        logging.error(f"Ping error for {ip}: {e}")
        return False

# Function to extract IP address from URL
def extract_ip(url):
    return urlparse(url).hostname

# Function to check miners
def check_miner(url, max_temp, min_hashrate_5s, min_hashrate_30m, expected_wallet_address):
    ip = extract_ip(url)
    if not is_miner_accessible(ip):
        send_telegram_message(f"🔌 {ip} is not accessible")
        logging.info(f"{ip} is not accessible")
        return

    try:
        # Checking wallet
        conf_url = f"{url}/cgi-bin/get_miner_conf.cgi"
        response = requests.get(conf_url, auth=auth)
        response.raise_for_status()
        conf_data = response.json()
        wallet_address = conf_data.get("pools", [{}])[0].get("user")

        if wallet_address is None:
            message = f"🔍 {ip}: wallet information not found"
            send_telegram_message(message)
            logging.warning(message)
        elif wallet_address != expected_wallet_address:
            message = f"💰 {ip}: wallet address mismatch: {wallet_address}"
            send_telegram_message(message)
            logging.warning(message)
        else:
            logging.info(f"Wallet address for {ip} is correct: {wallet_address}")

        # Checking temperature and hashrate
        temp_url = f"{url}/cgi-bin/stats.cgi"
        response = requests.get(temp_url, auth=auth)
        response.raise_for_status()
        data = response.json()

        # Checking uptime
        elapsed_seconds = data["STATS"][0]["elapsed"]
        uptime = format_uptime(elapsed_seconds)

        for stat in data["STATS"]:
            temps = stat["chain"]
            for chain in temps:
                temp_chip = max(chain["temp_chip"])
                temp_pcb = max(chain["temp_pcb"])
                logging.info(f"Temperature for {ip}: CHIP {temp_chip}°C, PCB {temp_pcb}°C")
                if temp_chip >= max_temp:
                    message = f"🔥 {ip} CHIP temperature: {temp_chip}°C"
                    send_telegram_message(message)
                    logging.warning(message)
                if temp_pcb > 70:
                    message = f"🔥 {ip} PCB temperature: {temp_pcb}°C"
                    send_telegram_message(message)
                    logging.warning(message)

        rate_5s = data["STATS"][0]["rate_5s"]
        rate_30m = data["STATS"][0]["rate_30m"]
        if rate_5s < min_hashrate_5s or rate_30m < min_hashrate_30m:
            message = f"📉 {ip}: low hashrate. 5s: {rate_5s} Mh/s, 30m: {rate_30m} Mh/s, uptime: {uptime}"
            send_telegram_message(message)
            logging.warning(message)
        else:
            logging.info(f"Hashrate is sufficient for {ip}: 5s: {rate_5s} Mh/s, 30m: {rate_30m} Mh/s, uptime: {uptime}")
    except requests.RequestException as e:
        message = f"🔌 {ip} is not accessible"
        send_telegram_message(message)
        logging.error(f"Request error for {url}: {e}")

# Checking all miners
for miner_type, miner_data in miners.items():
    for url in miner_data["urls"]:
        if miner_type == "L7":
            if miner_data.get("wallet"):
                expected_wallet_address = miner_data["wallet"]
            elif miner_data.get("wallet_prefix"):
                ip = extract_ip(url)
                expected_wallet_address = f"{miner_data['wallet_prefix']}.{ip.split('.')[-1]}"
            else:
                raise ValueError("Either wallet_l7 or wallet_prefix_l7 must be provided for L7 miners.")
        else:
            expected_wallet_address = miner_data["wallet"]
        logging.info(f"Checking {miner_type} at {url}")
        check_miner(url, miner_data["max_temp"], miner_data["min_hashrate_5s"], miner_data["min_hashrate_30m"], expected_wallet_address)
